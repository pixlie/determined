use crate::error::DetResult;
use serde::Deserialize;
use ts_rs::TS;

pub mod date;

const TS_FILE_HEADER: &str = "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.";

fn clean_ts_type(s: &str) -> String {
    let s = s.replace(TS_FILE_HEADER, "").replace("export ", "");
    s.trim()
        .lines()
        .filter(|l| !l.starts_with("import"))
        .collect::<Vec<&str>>()
        .join("\n")
}

#[derive(Debug, Deserialize, PartialEq, TS)]
pub enum EntityLabel {
    Integer,
    Float,
    Date,
    Time,
}

pub struct EntityExtractionRequest {
    pub entity_labels: EntityLabel,
    pub variable_name: String,
}

pub enum DeterminedRequest {
    EntityExtraction(Vec<EntityExtractionRequest>),
}

impl DeterminedRequest {
    fn get_entity_extraction_prompt(
        _extraction_request: &Vec<EntityExtractionRequest>,
        payload: String,
    ) -> String {
        let type_entity_label = clean_ts_type(&EntityLabel::export_to_string().unwrap());

        format!(
            r#"
You have to respond in JSON using the following types:

```typescript
{}

type ExtractedData {{
    label: EntityLabel,
    matched_text: string,
    starting_position: number,
}};

type LLMResponse = Array<ExtractedData>;
```

Please extract data from the following text and respond only in JSON without prelude using type `LLMResponse`:

{}"#,
            type_entity_label, payload
        )
    }

    pub fn get_llm_prompt(&self, payload: String) -> String {
        match self {
            DeterminedRequest::EntityExtraction(requests) => {
                Self::get_entity_extraction_prompt(requests, payload)
            }
        }
    }

    pub fn process(&self, _text: &str) -> DetResult<Vec<ExtractedEntity>> {
        Ok(vec![])
    }
}

#[derive(Deserialize, TS)]
pub struct ExtractedEntity {
    pub entity_label: EntityLabel,
    pub matched_text: String,
    pub variable_name: String,
    pub start: usize,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_llm_prompt() {
        let request = DeterminedRequest::EntityExtraction(vec![EntityExtractionRequest {
            entity_labels: EntityLabel::Date,
            variable_name: "transaction_date".to_string(),
        }]);

        let prompt = request.get_llm_prompt(
            "You made a purchase of Rs. 454 on Jan 23, 2022 at 10:32 AM.".to_string(),
        );
        assert_eq!(
            prompt,
            r#"
You have to respond in JSON using the following types:

```typescript
type EntityLabel = "Integer" | "Float" | "Date" | "Time";

type ExtractedData {
    label: EntityLabel,
    matched_text: string,
    starting_position: number,
};

type LLMResponse = Array<ExtractedData>;
```

Please extract data from the following text and respond only in JSON without prelude using type `LLMResponse`:

You made a purchase of Rs. 454 on Jan 23, 2022 at 10:32 AM."#
        );
    }

    #[test]
    fn test_extracted_entity() {
        let request = DeterminedRequest::EntityExtraction(vec![EntityExtractionRequest {
            entity_labels: EntityLabel::Date,
            variable_name: "transaction_date".to_string(),
        }]);

        let result =
            match request.process("You made a purchase of Rs. 454 on Jan 23, 2022 at 10:32 AM.") {
                Ok(entities) => {
                    assert_eq!(entities.len(), 1);
                    let extracted_date = &entities[0];

                    assert_eq!(extracted_date.entity_label, EntityLabel::Date);
                    assert_eq!(extracted_date.matched_text, "Jan 23, 2022");
                    assert_eq!(extracted_date.variable_name, "transaction_date");
                    assert_eq!(extracted_date.start, 34);
                }
                Err(err) => panic!("Did not get expected entities: {}", err),
            };
    }
}
