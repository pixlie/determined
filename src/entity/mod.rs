use crate::error::{DetError, DetResult};
use date::DetDate;
use serde::Deserialize;
use ts_rs::TS;
pub mod date;

const TS_FILE_HEADER: &str = "// This file was generated by [ts-rs](https://github.com/Aleph-Alpha/ts-rs). Do not edit this file manually.";

fn clean_ts_type(s: &str) -> String {
    let s = s.replace(TS_FILE_HEADER, "").replace("export ", "");
    s.trim()
        .lines()
        .filter(|l| !l.starts_with("import"))
        .collect::<Vec<&str>>()
        .join("\n")
}

#[derive(Debug, Deserialize, PartialEq, TS)]
pub enum EntityLabel {
    Integer,
    Float,
    Date,
    Time,
}

#[derive(Debug, Deserialize, TS)]
pub struct ExtractedData {
    pub label: EntityLabel,
    pub matched_text: String,
    pub variable_name: String,
    pub starting_position: usize,
}

pub struct EntityExtractionRequest {
    pub entity_label: EntityLabel,
    pub variable_name: String,
}

pub enum DeterminedRequest {
    EntityExtraction(Vec<EntityExtractionRequest>),
}

impl DeterminedRequest {
    fn get_entity_extraction_prompt(
        _extraction_request: &Vec<EntityExtractionRequest>,
        payload: String,
    ) -> String {
        let type_entity_label = clean_ts_type(&EntityLabel::export_to_string().unwrap());
        let type_extracted_data = clean_ts_type(&ExtractedData::export_to_string().unwrap());

        format!(
            r#"
You have to respond in JSON using the following types:

```typescript
{}
{}

type LLMResponse = Array<ExtractedData>;
```

Please extract data from the following text and respond only in JSON without prelude using type `LLMResponse`:

{}"#,
            type_entity_label, type_extracted_data, payload
        )
    }

    pub fn get_llm_prompt(&self, payload: String) -> String {
        match self {
            DeterminedRequest::EntityExtraction(requests) => {
                Self::get_entity_extraction_prompt(requests, payload)
            }
        }
    }

    pub fn request_llm(&self, _text: &str) -> DetResult<Vec<ExtractedData>> {
        let mock_response = r#"
[
    {
        "label": "Date",
        "matched_text": "Jan 23, 2022",
        "variable_name": "transaction_date",
        "starting_position": 31
    }
]"#;
        match serde_json::from_str::<Vec<ExtractedData>>(mock_response) {
            Ok(parsed) => Ok(parsed),
            Err(e) => Err(DetError::InvalidJSONFromLLM(e.to_string())),
        }
    }

    pub fn process(&self, text: &str) -> DetResult<Vec<DetResult<ExtractedData>>> {
        // Call AI with the prompt and pass the responses to the process functions of each requested data type
        let response_from_ai: Vec<ExtractedData> = self.request_llm(text)?;

        match self {
            Self::EntityExtraction(requested_list) => Ok(requested_list
                .iter()
                .map(|requested_item| {
                    match response_from_ai
                        .iter()
                        .find(|item| item.variable_name == requested_item.variable_name)
                    {
                        Some(item_in_ai_response) => match requested_item.entity_label {
                            EntityLabel::Date => {
                                DetDate::process(text, requested_item, item_in_ai_response)
                            }
                            _ => Err(DetError::MissingItemInResponseFromLLM(
                                requested_item.variable_name.clone(),
                            )),
                        },
                        None => Err(DetError::MissingItemInResponseFromLLM(
                            requested_item.variable_name.clone(),
                        )),
                    }
                })
                .collect()),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_get_llm_prompt() {
        let request = DeterminedRequest::EntityExtraction(vec![EntityExtractionRequest {
            entity_label: EntityLabel::Date,
            variable_name: "transaction_date".to_string(),
        }]);

        let prompt = request.get_llm_prompt(
            "You made a purchase of Rs. 454 on Jan 23, 2022 at 10:32 AM.".to_string(),
        );
        assert_eq!(
            prompt,
            r#"
You have to respond in JSON using the following types:

```typescript
type EntityLabel = "Integer" | "Float" | "Date" | "Time";

type ExtractedData {
    label: EntityLabel,
    matched_text: string,
    starting_position: number,
};

type LLMResponse = Array<ExtractedData>;
```

Please extract data from the following text and respond only in JSON without prelude using type `LLMResponse`:

You made a purchase of Rs. 454 on Jan 23, 2022 at 10:32 AM."#
        );
    }

    #[test]
    fn test_extracted_entity() {
        let request = DeterminedRequest::EntityExtraction(vec![EntityExtractionRequest {
            entity_label: EntityLabel::Date,
            variable_name: "transaction_date".to_string(),
        }]);

        let extracted =
            request.process("You made a purchase of Rs. 454 on Jan 23, 2022 at 10:32 AM.");
        assert!(extracted.is_ok());

        let extracted = extracted.unwrap();
        assert_eq!(extracted.len(), 1);

        for extracted_item in extracted {
            match extracted_item {
                Ok(extracted_data) => {
                    assert_eq!(extracted_data.label, EntityLabel::Date);
                    assert_eq!(extracted_data.matched_text, "Jan 23, 2022");
                    assert_eq!(extracted_data.variable_name, "transaction_date");
                    assert_eq!(extracted_data.starting_position, 34);
                }
                Err(err) => panic!("Did not get expected entities: {}", err),
            }
        }
    }
}
